<html xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="~{layouts/layout}" layout:fragment="content">
<head>
<meta charset="UTF-8">
<title>이조텍스SCM</title>
<link rel="stylesheet"
	href="https://uicdn.toast.com/grid/latest/tui-grid.css" />
<style>
#container {
	display: flex;
	justify-content: left;
}
@media (max-width: 768px) {
  #container {
    flex-direction: column; /* 세로 정렬 */
  }
}
.search-bar {
	width: 800px;
	height: 300px;
	display: inline-block;

}
.order-list {
	width: 800px;
	height: 778px;
}

.order-info {
	margin-top: 0;
	margin-left: 30px;
	width: 820px;
	height: 100%;
}

.search-unit {
	display: flex;
	margin-bottom: 5px;
}

.search-unit div {
	display: inline-block;
}

.search-bar>div {
	display: inline-block;
	vertical-align: top; /* 정렬 보정 */
}

.search-bar div:nth-of-type(1) {
	padding-left: 10px;
	width: 300px;
}

.search-bar div:nth-of-type(2) {
	padding-left: 10px;
	width: 410px;
}

.search-unit span {
	font-size: smaller;
	line-height: 2.5;
	width: 67px;
}

.search-bar div:nth-of-type(1) input {
	margin-left: 10px;
}

.search-bar div input[type=text] {
	width: 140px;
}

.search-bar select {
	margin-left: 10px;
	width: 140px;
	border: 1px solid #dee2e6;
	font-weight: 400;
	font-size: 0.875rem;
	border-radius: 4px;
	height: 2rem;
}

input[type=date] {
	width: 140px;
}

.search-bar input[type=number] {
	width: 140px;
}

.dash {
	line-height: 1.9;
	margin-left: 2px;
	margin-right: 2px;
}

.search-bar b {
	display: block;
	margin-bottom: 5px;
}

.order-list b {
	display: block;
	margin-bottom: 5px;
}

.search-bar .btn-section {
	width: 390px !important;
	display: flex;
	justify-content: right;
	margin-bottom: 10px;
}

.btn-secondary {
	background-color: #b1b1b1;
}

.btn-section button:nth-of-type(2) {
	margin-left: 10px;
}

#order-details .table td {
	padding: 5px;
}

.table textarea {
	height: 60px;
}

#productListgrid {
	width: 100%;
	height: 280px; /* 충분한 높이를 설정 */
}

.detailAmount {
	margin-top: 10px;
	-webkit-box-shadow: 0 0 0 0 rgba(90, 113, 208, 0), 0 4px 16px 0
		rgba(167, 175, 183, 0);
}

.detailAmount input[type=number] {
	width: 120px;
	margin-right: 20px;
	margin-left: 5px;
}

.input-details {
	display: flex;
	line-height: 1.9;
	justify-content: center;
}


.completeBtn-section {
	display: flex;
	justify-content: center;
}


.completeBtn-section button {
	margin: 10px;
}

#productListgrid {
	height: 300px;
}

#order-details {
	margin-bottom: 30px;
}

#productListgrid {
	margin-bottom: 24px;
}

.restQyModalHead {
	margin-bottom: 30px;
}
.input-total-qy {
	text-align: right;
}
.input-total-price {
	text-align: right;
}
.auto-input-btn {
	margin-left: 73%;
}
.card-body {
	flex: none !important;
}
</style>

</head>
<body>
	<h3 class="fs-3 fw-bold">| 납품등록</h3>
	<div id="container">
		<div>
			<div class="p-3 mb-2 bg-secondary text-dark card search-bar">

				<p class="fs-5 fw-bolder mb-3">검색</p>

				<!-- 검색조건1: 주문 코드, 납품 코드, 제품코드, 제품명, 주문담당자, 납품담당자, 상태 -->
				<div>
					<span class="search-unit"> <span>주문 코드</span> <input
						type="text" class="form-control search-code">
					</span> <span class="search-unit"> <span>주문담당자</span> <input
						type="text" class="form-control search-charger">
					</span> <span class="search-unit"> <span>업체코드</span> <input
						type="text" class="form-control search-company-code">
					</span> <span class="search-unit"> <span>업체명</span> <input
						type="text" class="form-control search-company-name">
					</span> <span class="search-unit search-status-group"> <span>상태</span>
						<select class="search-status">
							<option value="">전체</option>
							<option value="OR01">대기</option>
							<option value="OR06">분할출고</option>
					</select>
					</span>

				</div>

				<!-- 검색조건2: 주문일 납기일 수량합계 급액합계 업체코드 업체명 -->
				<div>

					<span class="search-unit"> <span>주문일</span> <input
						type="date" class="form-control search-date-start"> <b
						class="dash">-</b> <input type="date"
						class="form-control search-date-end">
					</span> <span class="search-unit"> <span>납기일</span> <input
						type="date" class="form-control search-dedt-start"> <b
						class="dash">-</b> <input type="date"
						class="form-control search-dedt-end">
					</span> 
					
					<!-- 
					<span class="search-unit"> <span>급액합계</span> <input
						type="number" class="form-control search-amount-start"> <b
						class="dash">-</b> <input type="number"
						class="form-control search-amount-end">
					</span> 
					 -->
					
					<span class="search-unit"> <span>제품코드</span> <input
						type="text" class="form-control search-product-code">
					</span> <span class="search-unit"> <span>제품명</span> <input
						type="text" class="form-control search-product-name">
					</span>
					<div class="btn-section">
						<button class="btn btn-warning mag-glass-btn"
							onclick="searchOrderList()">
							<i class="fa-solid fa-magnifying-glass icon-left"
								style="color: #ffffff;"></i>
						</button>
						<button class="btn btn-secondary mag-glass-btn"
							onclick="resetCondition()">
							<i class="fa-solid fa-repeat icon-left" style="color: #ffffff;"></i>
						</button>
					</div>
				</div>
			</div>
			<div class="card card-body mt-3 order-list">
				<p class="fs-5 fw-bolder mb-3">주문목록</p>
				<div id="grid"></div>
			</div>
		</div>
		<div class="card card-body order-info">
			<div id="order-details">
				<p class="fs-5 fw-bolder mb-3">납품 등록</p>
				<table class="table mt-3">
					<tbody>
						<tr>
							<td>구매업체코드</td>
							<td><input type="text"
								class="form-control input-company-code" disabled></td>
							<td>구매업체명</td>
							<td><input type="text"
								class="form-control input-company-name" disabled></td>
						</tr>
						<tr>
							<td>납품주소</td>
							<td colspan="3"><input type="text"
								class="form-control input-address" disabled></td>

						</tr>
						<tr>
							<td>주문일</td>
							<td><input type="text" class="form-control input-order-date"
								disabled></td>
							<td>납기일</td>
							<td><input type="text" class="form-control input-dedt"
								disabled></td>
						</tr>
						<tr>
							<td>주문담당자</td>
							<td><input type="text"
								class="form-control input-order-charger" disabled></td>
							<td>납품담당자</td>
							<td><input type="text"
								class="form-control input-delivery-charger" disabled></td>
						</tr>
						<tr>
							<td>제품수량합계</td>
							<td><input type="text" class="form-control input-total-qy"
								disabled></td>
							<td>주문금액합계</td>
							<td><input type="text"
								class="form-control input-total-price" disabled></td>
						</tr>
						<tr>
							<td>비고</td>
							<td colspan="3"><textarea class="form-control input-memo"></textarea></td>
						</tr>
						<tr>
							<td></td>
						</tr>
					</tbody>
				</table>
			</div>
			<div id="product-info">
				<b>납품 제품 상세</b>
				<div id="productListgrid"></div>
			</div>
			<div id="product-details">
				<b>납품 수량 입력</b><!-- 배포환경에서 p태그로 감싸져 있음 확인 필요 -->
				<button class="btn btn-outline-primary auto-input-btn btn-sm mb-1">자동수량입력</button>
				<div id="productDetailgrid"></div>
			</div>
			<div class="completeBtn-section">
				<button type="button" class="btn btn-primary sendData"
					data-bs-toggle="modal">등록</button>
				<button class="btn btn-secondary resetBtn">초기화</button>
			</div>
		</div>
		<div id="toastContainer" class="toast-container"></div>
	</div>


	<!-- 등록 확인 모달 -->
	<div class="modal fade" id="registModal" tabindex="-1"
		aria-labelledby="exampleModalLabel" aria-hidden="true">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header" style="height: 20px;">
					<h5 class="modal-title" id="exampleModalLabel"
						style="font-size: 15px;">등록 확인</h5>
				</div>
				<div class="modal-body"
					style="text-align: center; padding: 44px; padding-bottom: 10px;">
					<div>
						<img src="/images/modal/regist.png" alt="등록확인이미지"
							style="width: 84px; height: 84px;">
					</div>
					<div>
						<p style="margin-top: 12px; font-size: 21px; font-weight: bold;">알림</p>
						<p>내용을 등록하시겠습니까?</p>
					</div>
				</div>
				<div class="modal-footer regist"
					style="display: flex; justify-content: center; border-top: none; padding-bottom: 45px;">
					<!-- -->
					<button type="button"
						class="btn btn-primary deliveryRegistBtn"
						data-bs-dismiss="modal">등록</button>
					<button type="button" class="btn btn-secondary denyBtn"
						data-bs-dismiss="modal">취소</button>
				</div>
			</div>
		</div>
	</div>

	<!-- 분할 배송 확인 모달 -->
	<div class="modal fade" id="splitDeliveryCheckModal" tabindex="-1"
		aria-labelledby="exampleModalLabel" aria-hidden="true">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header" style="height: 20px;">
					<h5 class="modal-title" id="exampleModalLabel"
						style="font-size: 15px;">수량 확인</h5>
				</div>
				<div class="modal-body"
					style="text-align: center; padding: 44px; padding-bottom: 10px;">
					<div>
						<img src="/images/modal/modify.png" alt="등록확인이미지"
							style="width: 84px; height: 84px;">
					</div>
					<div>
						<p style="margin-top: 12px; font-size: 21px; font-weight: bold;">납품
							수량 부족</p>
						<p>
							납품 수량이 부족합니다 <br> 수량이 부족한 경우 분할출고합니다.
						</p>
					</div>
				</div>
				<div class="modal-footer regist"
					style="display: flex; justify-content: center; border-top: none; padding-bottom: 45px;">
					<!-- -->
					<button type="button"
						class="btn btn-primary splitDeliveryBtn"
						data-bs-dismiss="modal">등록</button>
					<button type="button"
						class="btn btn-secondary splitDenyBtn"
						data-bs-dismiss="modal">취소</button>
				</div>
			</div>
		</div>
	</div>

	<!-- 잔여량 출력 모달 -->
	<div class="modal fade" id="restQyModal" tabindex="-1"
		aria-labelledby="exampleModalLabel" aria-hidden="true">
		<div class="modal-dialog modal-xl">
			<div class="modal-content">
				<div class="modal-header" style="height: 20px;">
					<h5 class="modal-title" id="exampleModalLabel"
						style="font-size: 15px;">등록 완료</h5>
				</div>
				<div class="modal-body"
					style="text-align: center; padding: 44px; padding-bottom: 10px;">
					<img src="/images/modal/regist.png" alt="등록확인이미지"
						style="width: 84px; height: 84px;">
					<p class="restQyModalHead"
						style="margin-top: 12px; font-size: 21px; font-weight: bold;">출고
						후 잔여량</p>
					<!-- 잔여량 출력 모달 -->
					<div id="restQyGrid"></div>
				</div>

				<div style="text-align: center; margin: 20px;">
					<button type="button"
						class="btn btn-secondary restQyModalClose"
						data-bs-dismiss="modal">닫기</button>
				</div>
			</div>
		</div>
	</div>
	<script>
			function numberFormat(value){ 
				
				if(value == 0) {
					return value;
				} else if(value == null || value == '') {
					return null;
				} else {
					return Number(value).toLocaleString();
				}

				
			};
			
		    //등록할 데이터 담을 변수
		    let registData = [];
		    
		    //등록할 데이터를 담을 변수에서 입력할 때 중복값이 생김 필터링된 새로운 배열
		    let filteredRegistData = [];
		    
		    
			//DB에서 가져온 원 데이터 저장 변수(바뀔 수 있음);
			let allOrderInfo = null;
			
			//원데이터 저장변수(바꾸지 않음)
			let originalData = null;
			
			//주문목록 그리드
		    const dataSource = {
		  	      api: {
		  	          readData: { url: '/delivery/orderList' , method: 'GET' },
		  	        },
		  	      contentType: 'application/json',
		  	    };  

	        const grid = new Grid({
	            el: document.getElementById('grid'),
	            rowHeaders: ['rowNum'],
	            pageOptions: {
	                useClient: false,    //데이터를 한번에 다 가져옴. 나중에 false로 할 예정
	                perPage: 15
	            },
	            bodyHeight: 619,
	            columnOptions: {
	  	          resizable: true
	  	      	},
	            columns: [
	                { header : "주문코드", name: "productOrderCode", sortable: true, align: 'center', minWidth:107},
	                { header : "업체코드", name: "companyCode", align: 'center', minWidth:67},
	                { header : "업체명", name: "company", sortable: true, align: 'left', minWidth:138 ,
	                	renderer: {
				            styles: {
				              fontWeight: 'bold'
				            }
				          }
	                },
	                { header : "요약", name: "summary", sortable: true, align: 'left', minWidth:137, ellipsis:true},
	                { header : "상태", name: "orderStatus", align: 'center', minWidth:63,
	                	renderer: {
	                        styles: {
	                          fontWeight: 'bold',
	                          color: props => {
	                              switch(props.value){
	                                 case '대기': return '#aaa';
	                                 case '부분출고': return '#4b96ea';
	                              }
	                          }
	                        }
	                      }
	                },
	                { header : "담당자", name: "orderCharger", sortable: true, align: 'center', minWidth:50},
	                { header : "주문일", name: "orderDate", sortable: true, align: 'center', minWidth:74},
	                { header : "납기일", name: "dedt", sortable: true, align: 'center', minWidth:74}
	            ],
	            data: dataSource,
				showDummyRows: true	//더미로우 추가
	        });
	        
	        
	        
	        function searchOrderList() {
	        	
	        	grid.readData(1, {
	        		orderCode: document.querySelector('.search-code').value,
	        		//deliveryCode: document.querySelector('.search-delivery-code').value,
	        		orderCharger:  document.querySelector('.search-charger').value,
	        		//deliveryCharger: document.querySelector('.search-delivery-charger').value,
	        		orderDateStart: document.querySelector('.search-date-start').value,
	        		orderDateEnd: document.querySelector('.search-date-end').value,
	        		dedtStart: document.querySelector('.search-dedt-start').value,
	        		dedtEnd: document.querySelector('.search-dedt-end').value,
	        		productCode: document.querySelector('.search-product-code').value,
	        		productName: document.querySelector('.search-product-name').value,
	        		//totalAmountStart: document.querySelector('.search-amount-start').value,
	        		//totalAmountEnd: document.querySelector('.search-amount-end').value,
	        		companyCode: document.querySelector('.search-company-code').value,
	        		companyName: document.querySelector('.search-company-name').value,
	        		orderStatus: document.querySelector('.search-status').value
	        		
	        	}, false);	//안에 값 넣으면 됨 파라미터 세개 (1:몊번째 페이지 불러올 것인가, 2:검색조건, 3:true=기존데이터 초기화)
	        }
	        
	        //검색 엔터 이벤트
			document.querySelectorAll(".search-bar input").forEach((ele) => {
				ele.addEventListener('keydown', (ele) => {				
					if (window.event.keyCode == 13) {
						searchOrderList();
				    }
				})
			})
			
	        //검색 조건 삭제
	        function resetCondition() {
        		document.querySelectorAll('.search-bar input').forEach((e) => {
        			e.value = null;
        		})
        		document.querySelector('.search-bar select').value = '';
        		searchOrderList();
	        }
	        

			let lastClicked = null; // 페이지 이동 시에도 이전 선택 기억하기 위함.
			
	        
	        //제품 목록
			const productListgrid = new Grid({
				el: document.getElementById('productListgrid'),
				bodyHeight: 250,
				scrollY: true,
				scrollX: false,
				rowHeaders: ['rowNum'],
				columns: [
					{ header: "주문번호", name: "productOrderCode", hidden: true},
					{ header: "제품코드", name: "productCode", minWidth: 120, width: 130, align: 'center'},
					{ header: "제품명", name: "productName", minWidth: 600, width: 'auto', align: 'left'},
					{ header: "주문수량합계", name: "reqQy", hidden: true}
				]
			});
			//숫자 콤마 넣는 함수
			function CommaFomatter(numVal){
				return numVal.toString().replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
			}
			
			
	        
	        //제품 상세 수량
		    const productDetailgrid = new Grid({
			      el: document.getElementById('productDetailgrid'), // 컨테이너 엘리먼트
		          scrollY: true,
			      scrollX: true,
			      bodyHeight: 200,
			      header: {
			        	height: 70,
			            complexColumns: [
			              {
			                header: 'S',
			                name: 'stest',
			                childNames: ['sizeS', 's', 'ins']
			              },
			              {
				             header: 'M',
				             name: 'mtest',
				             childNames: ['sizeM', 'm', 'inm']
				          },
				          {
					         header: 'L',
					         name: 'ltest',
					         childNames: ['sizeL', 'l', 'inl']
					      },
					      {
						      header: 'XL',
						      name: 'xltest',
						      childNames: ['sizeXl', 'xl', 'inxl']
						  }
			             ]},
			        columns: [
			            { header: "색상/사이즈", name: "productColor", align: "center", width:80 },
			            { header: "출고수량", name: "sizeS", align: "center", editor: "text"},
			            { header: "잔여수량", name: "s", align: "center" },
			            { header: "재고수량", name: "ins", align: "center" },
			            { header: "출고수량", name: "sizeM", align: "center", editor: "text"},
			            { header: "잔여수량", name: "m", align: "center" },
			            { header: "재고수량", name: "inm", align: "center" },
			            { header: "출고수량", name: "sizeL", align: "center", editor: "text"},
			            { header: "잔여수량", name: "l", align: "center" },
			            { header: "재고수량", name: "inl", align: "center" },
			            { header: "출고수량", name: "sizeXl", align: "center", editor: "text"},
			            { header: "잔여수량", name: "xl", align: "center" },
			            { header: "재고수량", name: "inxl", align: "center" }
			        ],
				  columnOptions: {
				        frozenCount: 1,
				        frozenBorderWidth: 1,
				        minWidth: 150
				      }
			    });  
	        
			//주문 상세 데이터 모두 가져오기
	        grid.on('focusChange', ev => {
	        	//제품 상세 입력 그리드 초기화
	        	productDetailgrid.clear();
	        	
	        	document.querySelector(".input-delivery-charger").value = session_user_name;
	        	//다른 주문건 선택할 때마다 출고 수량입력했던 데이터 초기화
	        	
	        	
	        	registData = [];	//보내는 데이터를 담을 변수 초기화
	        	filteredRegistData = [];	//보내는 데이터를 담을 변수를 바로 입력할 수 있도록 필터링된 배열(실제로 보내는 데이터) 초기화
	        	
	            // 배경색 클래스 적용
	            grid.removeRowClassName(lastClicked, 'bg-blue'); // 이전 선택 행 배경색 삭제
	            grid.addRowClassName(ev.rowKey, 'bg-blue'); // 선택된 행 배경색 추가
	            lastClicked = ev.rowKey; // 선택된 행 기억

	            // 선택한 정보 가져오기
	            let selected = grid.getRow(ev.rowKey);
	            
	            console.log(selected);
	            document.querySelector('.input-company-code').value = selected.companyCode;
	            document.querySelector('.input-company-name').value = selected.company;
	            document.querySelector('.input-order-date').value = selected.orderDate;
	            document.querySelector('.input-dedt').value = selected.dedt;
	            /*구매업체코드, 구매업체명,
	            납품주소, 주문일, 납기일
	            주문담당자, 납품담당자,
	            제품수량합계, 주문금액합계,
	            비고
	            제품코드, 대분류, 소분류, 제품명, 출고량 합계*/
	            
	            //스피너
	            loading(900);
	            
				//주문 상세정보 가져오기
		    	fetch(`/delivery/orderInfo?orderCode=${selected.productOrderCode}`)
	    		.then(rep => rep.json())
	    		.then(data => {
	    				
	    				//등록해야되는 정보 처음 가져온 내용
	    				allOrderInfo = data;
	    				
	    				console.log('수정하는 원데이터', allOrderInfo);
	    				
	    				let sum = 0;
	    				data.orderInfo.forEach(e => {sum += e.reqQy});	//주문합계 구하기
	    				
	    				
	    				document.querySelector('.input-address').value = data.orderInfo[0].address;	//납품 주소
	    				document.querySelector('.input-total-price').value = CommaFomatter(data.orderInfo[0].amount);	//금액 합계
	    				document.querySelector('.input-order-charger').value = data.orderInfo[0].charger;	//주문담당자
	    				document.querySelector('.input-total-qy').value = CommaFomatter(sum);	//주문 합계
	    				
	    				
	    				
	    				for(let i=0; i<allOrderInfo.productDetails.length; i++) {	//2번
	    					
	    					//이미 출고 수량을 모두 채운 경우 화면에서 출력하지 않기 위한 splice / 하지 않으면 빈행이 출력됨.
		            		if(allOrderInfo.productDetails[i].qyList.length == 0) {		            			
			            		allOrderInfo.productDetails.splice(i, 1);	//작동됐음.
			            		allOrderInfo.orderInfo.splice(i, 1);
		            		} 		  
		            		
	    					for(let k=0; k<allOrderInfo.productDetails[i].qyList.length; k++) {	    	//4번					
	    						
			    				for(let j=0; j<allOrderInfo.orderInfo.length; j++) {	//2번
			    					//console.log("앞에꺼allOrderInfo.productDetails[i].qyList[k].productCode", allOrderInfo.productDetails[i].qyList[k].productCode, "뒤에꺼", allOrderInfo.orderInfo[j].productCode);
			    					if(allOrderInfo.productDetails[i].qyList[k].PRODUCT_CODE == allOrderInfo.orderInfo[j].productCode) {
			    						//console.log("제품명 넣기 작동됨");
			    						allOrderInfo.productDetails[i].qyList[k].productName = allOrderInfo.orderInfo[j].productName;
			    					}
			    				}
	    					}
	    				}
	    				
	    				
	    				//데이터 넣기
	    				productListgrid.resetData(allOrderInfo.orderInfo);
	    				
	    			})
	    		
	        }); 
	        
	        /*출고 후 잔여량 출력 모달*/
			const restQyGrid = new Grid({
				el: document.getElementById('restQyGrid'),
				bodyHeight: 250,
				scrollY: true,
				scrollX: false,
				width: 1050,
				rowHeaders: ['rowNum'],
				columnOptions: {
		  	          resizable: true
		  	      	},
				columns: [
					{ header: "제품코드", name: "productCode", width: "auto", minWidth: 120, align: 'center'},
					{ header: "제품명", name: "productName", width: "auto", minWidth: 380},
					{ header: "색상", name: "productColor", width: "auto", minWidth: 100, align: 'center'},
					{ header: "사이즈", name: "showSize", width: "auto", minWidth: 100, align: 'center'},
					{ header: "요청수량", name: "reqQy", width: "auto", minWidth: 100, align: 'center', formatter:(row)=>numberFormat(row.value)},
					{ header: "출고수량", name: "deliveryQy", width: "auto", minWidth: 100, align: 'center', formatter:(row)=>numberFormat(row.value)},
					{ header: "잔여량", name: "restQy", validation: {validatorFn: (value, row, columnName) => value <= 0}, width: "auto", minWidth: 100, align: 'center'}
				],
				showDummyRows: true	//더미로우 추가
			});
		    
	      //제품 선택
	        let productSelected = null;
	        let newProduct = null;
	        
		 	// 제품 상세보기 그리드 클릭 이벤트
		    productListgrid.on('focusChange', ev => {
		    	let data = productListgrid.getRow(ev.rowKey);
		    	
		    	//수량 초기화, 수량 자동입력에서 사용하기 위해 할당
		    	productSelectedEvData = data;
		    	
		    	productListgrid.removeRowClassName(productSelected, 'bg-blue'); // 이전 선택 행 배경색 삭제
		    	productListgrid.addRowClassName(ev.rowKey, 'bg-blue'); // 선택된 행 배경색 추가
	            productSelected = ev.rowKey; // 선택된 행 기억
	            
		    	// 선택한 제품코드 저장
	    		productCode = data.productCode;
	    		
	            
	    		console.log("data.productName, 제품명: " ,data.productName);
	            //사이즈 정보 담을 배열
	            let products = [];
	    		//사이즈 컬럼(그리드 헤더 - 제일 위)
	    		let size = [];
	            //색상, 사이즈 컬럼
				let color = [{ header: "색상/사이즈", name: "PRODUCT_COLOR", align: "center", minWidth: 80 }];
	            
	            //allOrderInfo객체에 재고수량 0을 넣기 위해서만든 변수(사이즈 이름을 가지고 있음)
	            let invenForZero = '';
	            
	    		for(let i=0; i<allOrderInfo.productDetails.length; i++) {
	            	
		            let cnt = 0;
		            for(let j=0; j<allOrderInfo.productDetails[i].optionList.length; j++) {
		            	
		            	if(allOrderInfo.productDetails[i].optionList[j].productCode == productCode) {

		            		//사이즈
	            			let sizeCode = allOrderInfo.productDetails[i].optionList[j].showSize;
		            		/*
		            			DE: 출고 수량 입력하는 컬럼
		            			RE: 잔여 수량 컬럼(입력하지 않음)
		            		    IN: 재고 수량(입력하지 않음)
		            		*/
		            		
		            		size.push({
				                header: sizeCode,
				                name: sizeCode+'head',
				                childNames: ['DE'+sizeCode, 'RE'+sizeCode, 'IN'+sizeCode],
				                minWidth: 150
				             })
				             
				            let reqSize = 'RE'+sizeCode;
		            		let invenSize = 'IN'+sizeCode;
		            		invenForZero = invenSize;
				           	//console.log(size);
			    			//allOrderInfo.productDetails[i].productSize
			    			
			    			//제품의 한 색상의 사이즈 컬럼을 하나씩 넣어서 그리드를 생성함
			    			color.push({ header: "출고량", name: 'DE'+sizeCode, align: "right", editor: "text", minWidth: 60, formatter:(row)=>numberFormat(row.value)},
			    					{ header: "잔여량", name: 'RE'+sizeCode , align: "right", minWidth: 60, formatter:(row)=>numberFormat(row.value) },
			    					{ header: "재고량", name: 'IN'+sizeCode, align: "right", minWidth: 60, formatter:(row)=> {
			    						//요청 수량이 0이 아니라면
			    						if(row.row[reqSize] != null) {
			    							if(row.value == 0) {
			    								return 0;
			    							} else if(row.value == null || row.value == '') {
			    								return 0;
			    							} else {
			    								return Number(row.value).toLocaleString();
			    							}
			    						} else {
			    							return null;
			    						}}
			    					})
							
		            	}
		            }
		            


		            	
		            for(let j=0; j<allOrderInfo.productDetails[i].qyList.length; j++) {
		            	//선택한 제품코드와 객체 배열 안에 있는 제품 코드가 같으면 배열에 넣고, 화면에 출력함.
		            	if(productCode == allOrderInfo.productDetails[i].qyList[j].PRODUCT_CODE) {	
			            	//서버에서 가져온 데이터 + 제품 이름 같이 넣었음.
			            	//allOrderInfo.productDetails[i].qyList[j][invenForZero] = 0;																	---------------------------------------이거 문제생길 가능성 많음 내가 왜 한지 모름
							products.push({...allOrderInfo.productDetails[i].qyList[j], productName : data.productName});
			            	
		            	}
		            	
		            }
		            
		            

	    		}
	    		
	    		/*
	    			product배열에서 제품의 색상 행의 반복 확인, 데이터는 중복됨. 아래 코드로 중복 제거
    				filter에서 가져온 products배열의 배열 번호와 findIndex로 가져온 products배열의 배열번호 중 
    				product_1과 product_2의 이중 반복문으로 PRODUCT_COLOR가 같은 배열번호를 리턴받아서 같은건 제외하여 새로운 newProduct라는 배열을 생성
    			*/
	    		const newProduct = products.filter((product_1, idx) => {
	    		            return (
	    		              products.findIndex((product_2) => {
	    		                return product_1.PRODUCT_COLOR === product_2.PRODUCT_COLOR
	    		              }) === idx
	    		            )
	    		          }
	    		        );
	    		
	    		//데이터 입력에 필요한 정보 마지막에 넣고 히든
				color.push({ header: "주문코드", name: "ORDER_CODE", align: "center", hidden:true},
						{ header: "제품코드", name: "PRODUCT_CODE", align: "center", hidden:true},
						{ header: "제품명", name: "productName", align: "center"});
				
				console.log("products: ", newProduct);	//중복없는 데이터
				
				productDetailgrid.setHeader({complexColumns:size});
				productDetailgrid.setColumns(color);
				productDetailgrid.resetData(newProduct);

		    	})
		    	
		    //초기화, 제품 수량 자동입력 기능시 제품이름을 넣기 위한 변수
			let selectedProductName = '';
		 	
	    	// 제품 옵션 그리드 체인지 이벤트(하나 또는 여러변경값)
	    	productDetailgrid.on('afterChange', ev => {
	    	    //console.log('선택 제품코드:', productCode);
	    	    
	    	    //초기화, 제품 수량 자동입력 기능시 제품이름을 넣기 위한 값 할당
				selectedProductName = rowData.productName;
	    	    
	    	    //if (!ev || !ev.changes) return; // 변경된 데이터가 없으면 종료
	    	    ev.changes.forEach(change => {
	    	    	//console.log(change.rowKey);
	    	        let rowData = productDetailgrid.getRow(change.rowKey); // 변경된 행 데이터 가져오기
	    	        let columnName = (change.columnName).replace("DE", ""); // 컬럼명('DE'붙어서 나옴)
	    	        let newValue = Number(change.value); // 변경된 값
	    	        let maxValue = 0; 					 // 컬럼에 들어갈 최대값 담을 변수
	    	        let color = rowData.PRODUCT_COLOR;	 // 제품 색상
    	        	let inputCol = "DE" + columnName;	 //사용자가 수량을 입력하는 컬럼
    	        	
	    	        console.log('newValue', newValue);
    	        	
        	        if(change.value < 0) {
    	        		failToast('입력값은 음수가 될 수 없습니다.');
    	        		rowData[inputCol] = 0;
    	        		productDetailgrid.setRow(change.rowKey, rowData);
    	        	    return;
    	        	}
        	        
        	        if(isNaN(newValue)) {
        	        	failToast('입력값은 문자가 들어갈 수 없습니다.');
        	        	rowData[inputCol] = 0;
        	        	productDetailgrid.setRow(change.rowKey, rowData);
    	        	    return;
        	        }
    	        	
        	        //0을 입력했을 경우
        	        if(newValue == 0) {
        	        	rowData[inputCol] = 0;
        	        }
        	        
    	        	//console.log('행데이터', rowData);
	    	        //console.log('입력한 행 정보: ', rowData);
	    	        //console.log('컬럼명: ', columnName);
	    	        //값 변경이 없을경우 종료
	    	        
	    	        
	    	        //요청수량 컬럼
	    	        let reqQy = 'RE' + columnName;
	    	        //재고 수량 컬럼
	    	        let invenQy = 'IN' + columnName;
	    	        
	    	        // 어떤 사이즈 컬럼이 변경되었는지 확인 후 요청 수량 가져오기
					maxValue = Number(rowData[reqQy]);
	    	        
	    	        // 재고 수량
	    	        invenValue = Number(rowData[invenQy]);
	    	        
	    	        if(newValue > invenValue) {
	    	        	failToast(`출고 수량은  ${invenValue}보다 클 수 없습니다.`);
	    	        	//재고 수량보다 출고 수량이 많을 경우 0으로 
	    	        	rowData[inputCol] = 0;
					    productDetailgrid.setRow(change.rowKey, rowData);
	    	        }
	    	        
	    	        // 입력값이 기존 요청 수량보다 크면 경고 후 변경 취소
	    	        if (newValue > maxValue) {
	    	        	//입력안된다는 알림
					    failToast(`입력값은  ${maxValue}보다 클 수 없습니다.`);
					    // 최대 값으로 되돌리기
					    rowData[inputCol] = maxValue;
					    productDetailgrid.setRow(change.rowKey, rowData);
					}
	    	        
	    	        
	    	        //가져온 전체 데이터 출력
	    	        console.log('전체 데이터:', allOrderInfo);
	    	        console.log('오리지널 데이터: ', originalData);
    	        	for(let i=0; i<allOrderInfo.productDetails.length; i++) {
    	        			
    	        		for(let j=0; j<allOrderInfo.productDetails[i].qyList.length; j++) {
    	        			//가독성을 위해서 변수로 저장
    	        			let info = allOrderInfo.productDetails[i].qyList;
    	        			
    	        			//필드를 배열로 만듦
    	        			let fieldList = Object.keys(info[j]);
    	        			
    	        			//요청한 사이즈를 담을 변수, 사이즈가 두개 이상이면 두개 이상 들어가는 배열이 됨.
    	        			let reqSize = [];
    	        			
    	        			//배열로 만든 필드 리스트를 순환하며 RE가 들어간 필드를 저장함.
    	        			for(let n=0; n<fieldList.length; n++) {
    	        				if(fieldList[n].startsWith("RE")) {
    	        					//console.log('객체 필드 배열 반복문 작동');
    	        					//배열이 될 수 있음.
    	        					reqSize.push(fieldList[n].replace("RE", ""));
    	        				}
    	        			}
    	        			//제품코드가 같고, 사이즈가 같고, 색이 같아야 함.
    	        			if((info[j].PRODUCT_CODE == rowData.PRODUCT_CODE) &&
    	        			   (info[j].PRODUCT_COLOR == color)) {

     	        			   for(let k=0; k<reqSize.length; k++) {
     	        				   if(reqSize[k] == columnName) {    
     	        					   console.log('새로운 값:', newValue);
		    	        				//객체에 사용자가 입력한 값을 추가함.
		    	        				info[j][inputCol] = newValue;
		    	        				info[j].productName = rowData.productName;
     	        				   }
     	        			   }
    	        				
    	        				
    	        			}
    	        			
    	        		}
    	        	}
    	  
	    	        
	    	    });
	    	});	
	        
	        //splitDeliveryCnt는 요청 수량에 비해 출고수량이 적으면, 0보다 커짐.
	        let splitDeliveryCnt = 0;
		 	
	      	
	      	
	        /*등록버튼 클릭*/
	        document.querySelector(".sendData").addEventListener('click', () => {
	        	
	        	//출고 수량을 모두 0을 입력했을 경우를 확인하기 위한 변수
	        	let allZeroCnt = 0;
	        	
	        	//alert('등록버튼 클릭 이벤트');
	        	//console.log(allOrderInfo);
	        	for(let i=0; i<allOrderInfo.productDetails.length; i++) {
        			
	        		for(let j=0; j<allOrderInfo.productDetails[i].qyList.length; j++) {
	        			//가독성을 위해서 변수로 저장
	        			let info = allOrderInfo.productDetails[i].qyList;
	        			
	        			console.log("info에 제품이름이 없으면 더 올라가야됨", info);
	        			
	        			//필드를 배열로 만듦
	        			let fieldList = Object.keys(info[j]);
	        			
	        			//요청한 사이즈를 담을 변수, 한 제품에 사이즈가 여러개면, 사이즈가 여러개 나올듯
	        			let sizeArr = Object.keys(info[j]).filter(key => key.startsWith("RE"));	
	        			//객체 키로 이루어진 문자로 이루어진 배열에서 필터로 RE로 시작하는 배열을 새롭게 반환
	        			//console.log('sizeArr', sizeArr);
	        			for(let n=0; n<sizeArr.length; n++) {
	        				//DE+사이즈 => 사용자가 입력한 값, RE+사이즈 => 요청 수량
	        				let size = sizeArr[n].replace("RE", "")
	        				let reqQy = "RE" + size;
		        			let deliveryQy = "DE" + size;
		        			
		        			//음수 조건이 안걸림.
		        			if(Number(info[j][deliveryQy]) < 0) {
		        				failToast('입력값은 음수가 될 수 없습니다');
		        				return;
		        			}
		        			if(isNaN(info[j][deliveryQy])) {
		        				failToast('출고 수량을 입력해주세요.');
		        				return;
		        			} 
		        			console.log("info[j].productName j=",j, info[j].productName);	//제품명 못가져옴
		        			
		        			//실제 서버로 보낼 객체
	        				let obj = {productCode: info[j].PRODUCT_CODE, productColor: info[j].PRODUCT_COLOR,
	        						   productSize: getSizeCommonCode(size), reqQy: info[j][reqQy],
	        						   deliveryQy: info[j][deliveryQy], productSe: "PT02",
	        						   productName: info[j].productName, showSize: size };
		        			
		        			//서버로 보낼 배열에 푸쉬
	        				registData.push(obj);
	        			}

	        			
	        		}
	        	}
	        	console.log("필터링 되기전,", registData);		//이때도 제품명 안들어감.
	        	//입력하면서 생기는 중복값 모두 제거
       		    filteredRegistData = registData.filter((product_1, idx) => {
   		            return (
   		            	registData.findIndex((product_2) => {
   		             		if(product_1.productCode === product_2.productCode &&
   		             			product_1.productColor === product_2.productColor &&
   		             			product_1.productSize === product_2.productSize) {
   		             		
   		             			return true;
   		             		}
   		             	
   		              }) === idx
   		            )
   		          }
   		        );
	        	
	        	
	        	
	        	//보내는 데이터 수량 부족한게 있는지 확인하기
	        	for(let i=0; i<filteredRegistData.length; i++) {
	        		
					//주문 선택후 아무것도 입력하지 않은 경우
					if(filteredRegistData.length == 0) {
						failToast('주문을 선택해주세요');
						registData = []; 
						filteredRegistData = [];
						return;
					}
	        		
	        		//값을 입력하지 않았다면 바로 리턴되어 동작하지 못하게 함.
	        		if(filteredRegistData[i].deliveryQy === undefined) {
	        			failToast('출고 수량을 확인해주세요');
	        			registData = []; 
						filteredRegistData = [];
	        			return;
	        		} 
	        		
	        		//값을 입력하지 않았다면 바로 리턴되어 동작하지 못하게 함.
	        		if(filteredRegistData[i].deliveryQy == 0) {
	        			allZeroCnt++;
	        		} 
	        		
	        		//출고 수량이 부족하다면 분할출고 할 수 있도록 구분값을 추가
	        		if(filteredRegistData[i].reqQy > filteredRegistData[i].deliveryQy) {
	        			splitDeliveryCnt++;
	        		}
	        		
	        	}
	        	
	        	if(allZeroCnt == filteredRegistData.length) {
        			registData = []; 
					filteredRegistData = [];
	        		failToast('모든 제품의 출고 수량이 0 입니다');
	        		return;
	        	}
	        	
        		let registModal = new bootstrap.Modal(document.getElementById("registModal"));
        		registModal.show();
	        })
	        
	        
	        
	        //마스터 정보 추가하기
	        function makeRegistData() {

	       	 
	        	let masterObj = {orderStatus: splitDeliveryCnt > 0 ? 'OR06' : 'OR03',	//주문상태
	        			         companySe: 'CP02',										//회사구분
	        			         productOrderCode: allOrderInfo.orderInfo[0].productOrderCode,	//제품 주문 코드
	        			         companyCode: document.querySelector('.input-company-code').value,
	        			         companyName: document.querySelector('.input-company-name').value,
	        			         orderDate: document.querySelector('.input-order-date').value,
	        			         dedt: document.querySelector('.input-dedt').value,
	        			         dedtAddress: document.querySelector('.input-address').value,
	        			         deliveryStatus: 'DS01',
	        			         remark: document.querySelector('.input-memo').value,
	        			         amount: allOrderInfo.orderInfo[0].amount,
	        			         chargerCode: session_user_code,
	        			       	 chargerName: session_user_name
	        			         };
	        	filteredRegistData.push(masterObj);
	        	
	        	registerDelivery();

	        }
	        
	        
	        //납품 처리 통신
			function registerDelivery() {
	        	//스피너
	        	//simulateLoading();
	        	console.log("filteredRegistData보내기 직전", filteredRegistData);
				
	        	
                const response = fetch('/delivery/deliveryRegist', {
                    method: 'post',
                    headers: {
                        "Content-Type": "application/json",
                        ...headers
                    },
                    body: JSON.stringify(filteredRegistData)
                })
                .then(res => res.json())
                .then(result => {
                	console.log('서버 통신결과:', result);
                	if(result.state == 'fail') {
                		
                		failToast('로트 수량이 부족합니다 재고를 확인해주세요');
                		//allOrderInfo = originalData;
                		
                		//DB에서 처음 가져온 그 데이터를 다시 바인딩
                		//allOrderInfo = originalData;
                		//console.log('오리지널 데이터: ', originalData);
                		//productDetailgrid.resetData(allOrderInfo);
                		//productDetailgrid.reloadData();
                		
                		//productDetailgrid.clear(); 	//그리드 내부 내용 안보이게 함.
                		productDetailgrid.refreshLayout();
                		productDetailgrid.resetData(originalData);
                		
                	} else if(result.state == 'success'){                    		
                     // 작업 성공 후 잔여량 출력 내용 계산하기
                     for (let i = 0; i < filteredRegistData.length; i++) {
                         // 요청수량 - 입력수량으로 잔여량을 구한 후 서버로 보낸 데이터 배열의 객체에 restQy 필드를 만들고 값 추가
                         let qy = filteredRegistData[i].reqQy - filteredRegistData[i].deliveryQy;
                         filteredRegistData[i].restQy = qy;
                     }
                     console.log("배열 마지막 빼기 전에", filteredRegistData);
                     //배열 마지막 삭제(주문 정보 삭제)
                     //filteredRegistData.length = registData.length - 1;
                     
                     filteredRegistData.pop();
                     
                     console.log("배열 마지막 뺀 다음 여기사 자꾸 undifined가 들어감", filteredRegistData);
                     
                     restQyGrid.resetData(filteredRegistData);

                     // 작업이 성공했으면 잔여량 모달 출력
                     const restQyModal = new bootstrap.Modal(document.getElementById("restQyModal"));
                     restQyModal.show();
                	} else {
                		failToast('작업을 실패했습니다 관리자에게 문의해주세요');
                	}
                    
                }).catch(err => console.log(err));
                
                
                
            }
	        
	        /* 납품 등록 */
	        document.querySelector('.deliveryRegistBtn').addEventListener('click', () => {
	        	//console.log(registData);
		       	if(splitDeliveryCnt > 0 ) {
		       	    //배송수량이 부족한 경우
		       	    const splitDeliveryCheckModal = new bootstrap.Modal(document.getElementById("splitDeliveryCheckModal"));
		       	   	splitDeliveryCheckModal.show();
		       	} else {
		       		//수량 다 맞춘 경우. 바로 출고 가능함.
		       		
		       		/*납품 등록*/
		       		makeRegistData();//출고 마스터 정보, 주문 상태값 변환 정보 배열에 추가 후 데이터 입력

		       	}
		       	
		        
	        }) 
	        
	        /* 분할 출고 등록*/
	        document.querySelector('.splitDeliveryBtn').addEventListener('click', () => {
	        	//alert('분할출고');
	        	makeRegistData();//출고 마스터 정보, 주문 상태값 변환 정보 배열에 추가 후 데이터 입력
	        })
	        
	        //등록 모달에서 취소버튼 클릭했을 경우
	        document.querySelector('.denyBtn').addEventListener('click', () => {
	        	//alert('취소버튼');
	        	//분할 출고 수량 0으로 만들기
	        	splitDeliveryCnt = 0;
	        	//서버로 보낼 데이터 빈 배열로 만들기
	        	registData = [];
	        	filteredRegistData = [];
	        	
	        })
	        
	        //분할출고 모달 취소버튼 클릭했을경우
	        document.querySelector('.splitDenyBtn').addEventListener('click', () => {
	        	//alert('분할 취소버튼');
	        	//분할 출고 수량 0으로 만들기
	        	splitDeliveryCnt = 0;
	        	//서버로 보낼 데이터 빈 배열로 만들기
	        	registData = [];
	        	filteredRegistData = [];
	        })
	        
			document.querySelector('.restQyModalClose').addEventListener('click', () => {
				location.href = location.href;
			})
			
			
			
			//그리드 다시 그리기  -> productSelectedEvData사용
			function reWriteGrid() {
				
	        	 //사이즈 정보 담을 배열
	            let products = [];
	    		//사이즈 컬럼(그리드 헤더 - 제일 위)
	    		let size = [];
	            //색상, 사이즈 컬럼
				let color = [{ header: "색상/사이즈", name: "PRODUCT_COLOR", align: "center", minWidth: 80 }];
	            
	            //allOrderInfo객체에 재고수량 0을 넣기 위해서만든 변수(사이즈 이름을 가지고 있음)
	            let invenForZero = '';
	            
	    		for(let i=0; i<allOrderInfo.productDetails.length; i++) {
	            	
		            let cnt = 0;
		            for(let j=0; j<allOrderInfo.productDetails[i].optionList.length; j++) {
		            	
		            	if(allOrderInfo.productDetails[i].optionList[j].productCode == productCode) {

		            		//사이즈
	            			let sizeCode = allOrderInfo.productDetails[i].optionList[j].showSize;
		            		/*
		            			DE: 출고 수량 입력하는 컬럼
		            			RE: 잔여 수량 컬럼(입력하지 않음)
		            		    IN: 재고 수량(입력하지 않음)
		            		*/
		            		
		            		size.push({
				                header: sizeCode,
				                name: sizeCode+'head',
				                childNames: ['DE'+sizeCode, 'RE'+sizeCode, 'IN'+sizeCode],
				                minWidth: 150
				             })
				             
				            let reqSize = 'RE'+sizeCode;
		            		let invenSize = 'IN'+sizeCode;
		            		invenForZero = invenSize;
				           	//console.log(size);
			    			//allOrderInfo.productDetails[i].productSize
			    			
			    			//제품의 한 색상의 사이즈 컬럼을 하나씩 넣어서 그리드를 생성함
			    			color.push({ header: "제품명", name: 'productName', align: "right", editor: "text", minWidth: 60, hidden:true},
			    					{ header: "출고량", name: 'DE'+sizeCode, align: "right", editor: "text", minWidth: 60, formatter:(row)=>numberFormat(row.value)},
			    					{ header: "잔여량", name: 'RE'+sizeCode , align: "right", minWidth: 60, formatter:(row)=>numberFormat(row.value) },
			    					{ header: "재고량", name: 'IN'+sizeCode, align: "right", minWidth: 60, formatter:(row)=> { console.log(row.value);
			    						//요청 수량이 0이 아니라면
			    						if(row.row[reqSize] != null) {
			    							if(row.value == 0) {
			    								return 0;
			    							} else if(row.value == null || row.value == '') {
			    								return 0;
			    							} else {
			    								return Number(row.value).toLocaleString();
			    							}
			    						} else {
			    							return null;
			    						}}
			    					})
							
		            	}
		            }
		            


		            	
		            for(let j=0; j<allOrderInfo.productDetails[i].qyList.length; j++) {
		            	//선택한 제품코드와 객체 배열 안에 있는 제품 코드가 같으면 배열에 넣고, 화면에 출력함.
		            	if(productCode == allOrderInfo.productDetails[i].qyList[j].PRODUCT_CODE) {	
			            	//서버에서 가져온 데이터 + 제품 이름 같이 넣었음.
			            	allOrderInfo.productDetails[i].qyList[j][invenForZero] = 0;
			            	
							let productListData = productListgrid.getData();
							
							console.log("productListData",productListData);
							
							for(let n=0; n<productListData.length; n++) {								
								if(allOrderInfo.productDetails[i].qyList[j].PRODUCT_CODE == productListData[n].productCode) {
									products.push({...allOrderInfo.productDetails[i].qyList[j], productName : productListData[n].productName});
								}
							}
							//조건절이 있어야함. 제품명이 맞는게 들어가야함.
		            	}
		            	
		            }

	    		}
	    		
	    		/*
	    			product배열에서 제품의 색상 행의 반복 확인, 데이터는 중복됨. 아래 코드로 중복 제거
    				filter에서 가져온 products배열의 배열 번호와 findIndex로 가져온 products배열의 배열번호 중 
    				product_1과 product_2의 이중 반복문으로 PRODUCT_COLOR가 같은 배열번호를 리턴받아서 같은건 제외하여 새로운 newProduct라는 배열을 생성
    			*/
	    		const newProduct = products.filter((product_1, idx) => {
	    		            return (
	    		              products.findIndex((product_2) => {
	    		                return product_1.PRODUCT_COLOR === product_2.PRODUCT_COLOR
	    		              }) === idx
	    		            )
	    		          }
	    		        );
	    		
	    		//데이터 입력에 필요한 정보 마지막에 넣고 히든
				color.push({ header: "주문코드", name: "ORDER_CODE", align: "center", hidden:true},
						{ header: "제품코드", name: "PRODUCT_CODE", align: "center", hidden:true},
						{ header: "제품명", name: "productName", align: "center", hidden:true});
				
				//console.log("products: ", newProduct);	//중복없는 데이터
				
				productDetailgrid.setHeader({complexColumns:size});
				productDetailgrid.setColumns(color);
				productDetailgrid.resetData(newProduct);
	        }
			
			document.querySelector('.resetBtn').addEventListener('click', () => {
				//location.href = location.href;
				//제품 상세 입력 그리드 초기화
	        	//allOrderInfo = originalData
	        	//productDetailgrid.resetData(allOrderInfo);
	        	//productDetailgrid.reloadData();
					for(let i=0; i<allOrderInfo.productDetails.length; i++) {
        			
	        		for(let j=0; j<allOrderInfo.productDetails[i].qyList.length; j++) {
	        			//가독성을 위해서 변수로 저장
	        			let info = allOrderInfo.productDetails[i].qyList;
	        			
	        			//필드를 배열로 만듦
	        			let fieldList = Object.keys(info[j]);
	        			
	        			//요청한 사이즈를 담을 변수, 한 제품에 사이즈가 여러개면, 사이즈가 여러개 나올듯
	        			let sizeArr = Object.keys(info[j]).filter(key => key.startsWith("RE"));	
	        			//객체 키로 이루어진 문자로 이루어진 배열에서 필터로 RE로 시작하는 배열을 새롭게 반환
	        			
	        			for(let n=0; n<sizeArr.length; n++) {
	        				//DE+사이즈 => 사용자가 입력한 값, RE+사이즈 => 요청 수량
	        				let size = sizeArr[n].replace("RE", "")
		        			let deliverySize = "DE" + size;
		        			let invenSize = "IN" + size;
		        			
	        				info[j][deliverySize] = 0;
	        			}
	        		}
	        	}
				reWriteGrid();
				successToast("수량이 변경되었습니다.");
	        	
			})
			
			
			//출고 수량 자동 생성
			document.querySelector(".auto-input-btn").addEventListener("click", () => {
				console.log('수정하는 데이터 출력', allOrderInfo);
				//allOrderInfo.productDetails 이 배열안에 qylist배열에서 0,1,2,3,,,찾아서 de사이즈 값 넣어주기
				
				for(let i=0; i<allOrderInfo.productDetails.length; i++) {
        			
	        		for(let j=0; j<allOrderInfo.productDetails[i].qyList.length; j++) {
	        			//가독성을 위해서 변수로 저장
	        			let info = allOrderInfo.productDetails[i].qyList;
	        			
	        			//필드를 배열로 만듦
	        			let fieldList = Object.keys(info[j]);
	        			
	        			//요청한 사이즈를 담을 변수, 한 제품에 사이즈가 여러개면, 사이즈가 여러개 나올듯
	        			let sizeArr = Object.keys(info[j]).filter(key => key.startsWith("RE"));	
	        			//객체 키로 이루어진 문자로 이루어진 배열에서 필터로 RE로 시작하는 배열을 새롭게 반환
	        			
	        			for(let n=0; n<sizeArr.length; n++) {
	        				//DE+사이즈 => 사용자가 입력한 값, RE+사이즈 => 요청 수량
	        				let size = sizeArr[n].replace("RE", "")
	        				let reqSize = "RE" + size;
		        			let deliverySize = "DE" + size;
		        			let invenSize = "IN" + size;
		        			
		        			let reqNum = info[j][reqSize];
		        			let invenNum = info[j][invenSize];
		        			
		        			let val = 0;
		        			val = invenNum == undefined ? 0 : invenNum;
		        			val = invenNum == null ? 0 : invenNum;
		        			
		        			//info[j].productName = '';
		        			if(reqNum > val) {
		        				info[j][deliverySize] = val;
		        			} else {		        				
			        			info[j][deliverySize] = reqNum;
		        			}
	        			}
	        			
	        			
	        		}
	        	}
				
				reWriteGrid();
				successToast("수량이 변경되었습니다.");
			})
    	</script>
</body>
</html>